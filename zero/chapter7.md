# 虚拟机 I: 堆栈运算

构建典型的基于对象的高级语言编译器的最初步骤，我们分两个部分来介绍，每个部分涵盖两章。高级语言将被翻译成
中间代码，然后中间代码被转化为机器语言，这两层转换模型的思想比较古老，最近被一些现代高级语言如 Java 和 C#
所采用，因此该模型得到了复兴

基本思想：中间代码运行在虚拟机上，而不是真实的硬件平台上。VM 是并不真实在的抽象计算机，但是却能在其他的计算机平台
上得以实现。为什么说这种思想极具意义，其中一个原因在于代码的可移植性。因为，VM 能够在多目标平台上相对轻松地实现，
因此基于 VM 的软件不经过修改源代码就可以在不同的处理器和操作系统上运行

VM 的实现可以通过多种途径，通过软件翻译器，通过特殊用途的硬件，或者通过把 VM 程序翻译成目标平台的机器语言

虚拟机模型一般配有一种语言，可以利用这种语言来编写 VM 程序，VM 语言包括 4 种类型的命令：算术命令、内存访问命令、
流程控制命令和子程序调用命令。我们把这种语言实现分成两部分，每一部分都会在独立的章节和项目里面进行介绍。

本章构建基本的 VM 翻译器，它能将 VM 的算术命令和内存访问命令翻译成机器语言，再加入程序流程和子程序调用功能，
就是完整的虚拟机

虚拟机的出现论证了计算机科学领域里面的很多重要思想，首先将一台计算机在另一台机器上面进行仿真的概念，是这个领域
里基本思想之一，可以追溯到上世纪 30 年代的 `阿兰·图灵`

其后的几十年里此概念得到了很多实际的应用，比如在计算机平台上应用模拟器仿真先前的计算机来实现代码的向上兼容。
虚拟机模型成为两种具竞争关系的主流架构的中心焦点 -- Java 体系和.Net 架构，这些软件环境相当复杂，想要了解其内部结构，
方法之一是构建其 VM 内核的简单版本

这一章里面重要主题是堆栈处理，堆栈是基本且精良的数据结构，存在于很多计算机系统和算法中，VM 也正为堆栈这个功能强大的
数据结构提供了鲜活的实例

高级语言程序能够在目标计算机上运行之前，它必须被翻译成计算机的机器语言，这个翻译工作，也就是编译，
是相当复杂的过程。通常必须对任意给定的高级程序和对应的机器语言编写专用的编译器。每种编译器编译的高级语言
与编译之后的机器语言之间存在很强的依赖性，减少这种依赖性的方法之一是，将整个编译过程划分成两个几乎独立的
阶段。在第一个阶段，高级程序被解析出来，其命令被翻译成一种中间处理结果 -- 既不高级也不低级的中间结果
第二个阶段，这些中间结果被近一步翻译成目标的机器语言

从软件工程的角度来分析是非常吸引人的，第一阶段近依赖于高级语言的细节，第二个阶段仅依赖于目标机器语言的细节。
第一个程序，将高级版代码翻译成中间 VM 指令，第二个程序将这个 VM 代码翻译成目标计算机硬件平台的机器语言

## 虚拟机的优点

仅需替换虚拟机实现部分就能相对容易地得到不同硬件平台的编译器

虚拟机思想的另一个优点是模块，VM 效率的每一个改善都会立即被所有构建于其上的编译器继承，同样地，每个安装有 VM 实现的数字
设备都能够受益于现有软件的庞大基础

## 堆栈机模型

在堆栈机模型里，算术命令将其操作数从堆栈顶弹出，并将结果从栈顶压入。其他的命令将数据项从堆栈顶弹出，并转移到指定的内存单元，
或反向操作。经证明，这些简单的堆栈操作可以被用来计算任何数学或逻辑表达式，此外，任何程序，不管它用那种程序语言编写，都能被翻译
成等价的堆栈机语言

堆栈是抽象的数据结构，它支持两种基本操作：压入和弹出，压入操作是从堆栈顶部压入一个元素，当有新的元素从栈顶压入时，原栈顶的元素
向下移动一个单位，弹出操作是将栈顶的元素弹出，原来位于被弹出元素之下的元素就向上移动一个单位到达栈顶。堆栈执行的是后进现出
的存储模式

结构简洁的堆栈模型是具备多功能的数据结构，它在许多计算机系统和算法中得到应用，在我们这里构建的虚拟机系统里面，堆栈主要有两个
用途，它被用来处理所有 VM 的算术和逻辑操作，其次它使得子程序调用和相关的内存分配变得容易

## VM 规范

虚拟机是基于堆栈的，所有的操作都在堆栈上完成，它也是基于函数的，一个完整的、应用 VM 语言编写的 VM 程序
由若干个称为函数的程序单元组成，这些函数使用 VM 语言编写。每个函数都有自己独立的代码，并被独立地处理。

VM 语言使用单一的 16-位数据类型，它能够表示整数、布尔类型或者指针，该语言包含四种类型的命令

- 算术命令，在堆栈上执行算术和逻辑操作

- 存储器存取命令，在堆栈和虚拟内存单元之间转移数据

- 程序流程命令，使条件分支操作和无条件分支操作变得容易

- 函数调用命令，调用函数并返回调用处(即函数调用指令的下一条指令地址)

## 程序和命令结构

VM 程序是由一个或多个扩展名为`.vm`的文件构成的集合，而每个程序又包含一个或多个函数。从编译的角度来看，这些结构分别与
面向对象编程语言中的程序、类、方法的概念相对应

## 堆栈(stack)

考虑两条命令语句`push argument 2` `pop local 1`

这样的 VM 操作的工作内存就是堆栈，数值并不是简单的直接从一个单元跳到另一个单元，而是必须经过堆栈中转，尽管堆栈是 VM 结构中
的核心角色，但是在 VM 语言中从未显式地体现它的功能

## 堆(heap)

处在 VM 后端的另一个数据结构就是堆。堆是 RAM 区域的名字，用来存储对象和数组数据，这些对象和数组能够通过 VM 命令来操纵

## 程序流程控制命令和函数调用命令

**程序流程控制命令**

- label symbol 标签声明

- goto symbol 无条件分支

- if-goto symbol 条件分支

**函数调用命令**

- function 函数名 nLocals 函数声明

- call 函数名 nArgs 调用函数

- return 将程序控制权返回给调用者

## 数组处理

数组实际上就是一组有索引的对象集合。假设高级语言程序创建了名为 bar 的由 10 个整数组成的数组，然后填入 10 个数字。
在 C 语言里面，这样的操作可以被描述为`*(bar+2)=19`

## 对象处理

高级语言的程序员将对象看成是封装了数据和相关代码的实体。然而从本质上讲每个对象实例的数据是在 RAM 上被序列化成一串数字，
这串数字代表对象中各个字段的值，因此对象的低级处理和数组的低级处理很相似

像所有其他对象实例一样，它会被存储在 RAM 里，当程序在创建一个新对象，编译器都会以字为单位计算对象的大小，然后操作系统会
寻找一个足够大 RAM 空间并分配给该对象来存储它的内容

## 实现

构建 VM，从概念上包含两个任务，首先必须在目标平台上对 VM 进行仿真，特别是 VM 规范中提到的每个数据结构，也就是堆栈和
虚拟内存段，都必须通过某种方式在目标平台上表示出来，其次每个 VM 命令都必须被翻译成一系列具有目标平台语意的指令

VM 在 Hack 平台实现，首先得定义从 VM 要素和操作到 Hack 硬件和机器语言之间的标准映射，然后实现这种映射的软件设计思路

VM 设计者应该允许程序员用任何他们觉得合适的途径去在目标机上实现 VM

## 内存段映射

local, argument, this, that 每一个这样的段都直接映射到 RAM，通过专用寄存器分别是 LCL、ARG、THIS、THAT 来保存其
物理地址，就可以维持其在 RAM 中的位置。如此一来，对这些段的第 i 个数据项的访问，应该被翻译成`获得RAM中地址为base+i`的
值的汇编代码，这里 base 是存储在各段专有寄存器中的当前值

pointer, temp 这些段被直接映射在 RAM 中的一个固定区域上，pointer 段被映射在 RAM 位置 3 ～ 4 上，temp 段被映射在 RAM 位置 5 ～ 12 上。因此访问 point i 应该被翻译成访问 RAM 位置 3+i 的汇编代码，访问 temp i 应该被翻译成访问 RAM 位置 5+i 的汇编
代码

constant 这个段是真正虚拟的，因为它不占用目标平台上的任何物理存储空间，VM 实现通过简单地提供常数 i 来处理任何 VM 对`<constant i>`
的访问

## 项目

构建 VM 翻译器的第一个部分，主要包括堆栈运算和 VM 语言的内存访问命令

**初始化**

为了运行翻译过的 VM 程序，VM 程序必须包含一段启动代码，以便让 VM 实现在宿主平台上启动执行，另外，为了保证 VM
代码正常运作，VM 实现必须虚拟内存段的基地址映射到选定的 RAM 位置
