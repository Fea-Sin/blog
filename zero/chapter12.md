# 操作系统

我们描述并构建了称为 Hack 的计算机平台的硬件架构，以及该硬件架构得以运作的软件层级。
我们介绍了基于对象的语言 Jack，并描述了如何为 Jack 编写编译器。其他高级编程语言也能在 Hack 平台上应用，
只是每一门语言都需要各自的编译器

在整个构建中的最后一个接口就是操作系统(OS)， OS 的作用就是来衔接计算机硬件系统和软件系统，以使得整个计算机对
程序员和用户而言更容易使用

操作系统这个术语比较宽泛，本书所描述的 OS 服务包含了最小规模的操作系统，主要是

- 以一种对软件友好的方式封装了不同的硬件服务

- 用不同的函数和抽象数据类型扩展了高级语言，在这个意义上操作系统与语言的标准程序库的分界线就不是那么明显。事实上，
  某些现代语言就趋向于将很多经典的操作系统服务，比如 GUI 管理、内存管理和多任务管理连同很多语言扩展一起打包到其标准
  程序库中

本章描述并构建的服务就可以被看作简单的 OS 和 Jack 语言的标准程序库的集合。该 OS 被打包成一组 Jack 类，每个类通过 Jack
子程序调用来提供一组相关的服务。这个 OS 与工业级强度的操作系统有很多相似的特点，但是它仍然缺少大量的 OS 特性，比如进程
管理、磁盘管理、通信等

操作系统通常是由高级语言编写，并被翻译成二进制形式，就像任何其他程序一样，Jack 的 OS 也不例外，可以完全由 Jack 编写而成。
然而于其他由高级语言编写的程序不同的是，操作系统代码必须了解它所运行的硬件平台。换句话说，为了对高层的应用程序员隐藏这些硬件
细节，OS 程序员必须编写能够直接操纵这些细节的代码，这个任务需要参考硬件规范文档

本章的背景知识部分相对较长，描述了通常被用来实现基本操作系统服务的关键算法。这些服务包括数学函数、字符串操作、内存管理、
文本和图形输出到屏幕的处理，以及从键盘输入的处理

本章介绍了两个关键知识领域，一是涉及软件工程，二是涉及计算机科学。

## 数学操作

计算机系统必须支持诸如加法、乘法和除法这样的数学操作。通常，加法在 ALU 级的硬件中实现，其他操作如乘法和除法，可以根据计算机的
性价比要求，通过硬件或软件来处理。这一小节介绍乘法、除法以及平方根操作是如何在 OS 级的软件中被有效实现的。需要注意，这些数学
操作的硬件实现同样也是基于这里提到的算法

## 除法

计算两个 n-比特位的数的除法`x/y`，一种简单的方法是重复地从 x 上减去 y，直到无法继续。该算法的运行时间明显与除法的商成正比，
为了提高该算法的效率，可以在每次迭代中试着从 x 上减去 y 的一个比较大的倍数。在每次迭代中，试图从 x 上减去 y 的最大可能的位移，
也就是`y·T`，这种算法的二进制版本也是一样

按照上面的思路来编写算法是很容易的事情，但若把相同的逻辑用可能更容易实现的递归程序来表示，更具启发意义。这种递归算法的运行
时间由递归的深度来决定，因为在每次递归中，y 的值被乘上 2，一旦出现`y>x`立即结束。

## 平方根

可以采用很多不同的方法来有效地计算平方根，例如，牛顿-拉夫逊方法或泰勒级数展示式。对我们而言，采用较简单的方法就足够了，可以使用
二叉查找来计算平方根

## 数字的字符串表示

计算机在内部使用二进制码来表示数字，然而人们习惯于用十进制的表示来处理数字。因此当人们要读取或者输入数字时，计算机必须要执行
二进制到十进制的转换或者十进制到二进制的转换。通常这些工作由操作系统提供的底层服务程序来处理的

## 内存管理

计算机的程序会声明并使用各种类型的变量，包括如整数、布尔数等简单的数据类型以及如数组、对象等复杂的数据类型。高级语言
的最大优点之一是程序员不必关心内存管理细节，比如为变量分配内存空间，以及当该变量不再使用时，回收为其分配的内存空间。
所有关于内存管理的琐碎工作都由编译器、操作系统和虚拟机在后端来完成

不同变量的内存在程序生命周期中的不同时刻被分配。例如**静态变量**在编译期间由编译器为其分配内存，而**局部变量**则在每个子程序
开始运行时被分配在堆栈内。其他变量的内存则是在程序的执行过程中被动态分配，这就需要操作系统的帮助了。例如每当 Java 程序创建新数组
或新对象时，对应的内存块就被分配，而这块内存的大小只有在程序运行期间才能确定。当数组或对象不再使用时，其内存空间被收回，在一些
高级语言中如(C++/Jack)释放不再使用的内存空间是程序员的任务，然而在其他语言如 Java 中，会自动地产生垃圾回收。

被用于进行动态内存分配的内存段称为堆(heap)，负责管理这个资源的就是操作系统

操作系统使用不同的技术来处理动态内存分配和去配，这些技术通常在两个称为`alloc()`和`deAlloc()`的函数中实现

**基本内存管理算法**

该算法所管理的数据结构就是一个单一的指针，它指向还未经过分配的内存的堆基地址

显然，这个算法对内存的浪费程度很严重，因为它不回收那些不再使用的变量所占用的内存

**改进的内存分配算法**

该算法管理一个由可使用内存段构成的链表(freeList)，每个内存段包含两个字段，该内存段的长度和指向链表中下个内存段的指针，这些字段可被
保存在内存段起始的两个内存位置中

要分配指定大小的内存块时，该算法必须在 freeList 中搜索大小合适的内存段。有两种常用的启发式算法来完成此搜索任务。
第一种是**最优适应算法**
该算法在整个链表中搜索大小最匹配的内存段来分配给变量

第二种是**最先适应算法**
该算法将链表中找到的第一个大小能满足变量要求的内存段分配给变量，一旦找打合适的段，就从中取出所需要的内存块(返回起始位置的
前一个位置 block[-1]被用来保存其长度，在内存空间的去配过程中会用到该长度值)

接着该段在 freeList 中被更新，成为分配之后剩余的部分，如果块中没有剩余的内存，或者若剩余部分太小，则从 freeList 中去掉
整个段

收回无用对象的内存时，该算法将收回的块追加到 freeList 中

进过频繁分配、收回操作之后，动态分配机制会产生内存碎片。应该考虑一些碎片整理操作，将那些在物理上连续而在 freeList 中
从逻辑上被划分到不同内存段的内存区域合并起来，可以在对象被去配时，或`alloc()`没有找到合适内存块时执行碎片整理操作

## 变长数组和字符串

现代语言中常用方法是使用 String 类提供创建并操作字符串对象的服务，在物理上字符串对象可以通过使用数组来实现。
在创建字符串时，一般为该数组分配的空间足够用来保存可能的最大长度，而字符串的实际长度可能比最大的值要短，且应在字符串对象
的整个生命周期中保存该实际长度值

大多数编程语言都有字符串类型，以及其他变长数据类型，字符串对象通常由语言的标准程序库提供，比如 Java 语言中的 String 类和
StringBuffer 类

## 输入输出管理

计算机一般会连接到各种输入/输出设备，比如键盘、屏幕、鼠标、磁盘、网卡等，各种 I/O 设备都有其自己的机电特性和物理特性，因此
在这些设备上进行数据读写操作涉及很多技术细节。
对程序员而言，高级语言利用诸如`c=readChar()`和`printChar(c)`这样的高级操作指令将这些细节隐藏起来，实际的 I/O 操作是通过操作
系统提供服务实现的

如此一来，操作系统重要功能之一就是要处理连接到计算机上的各种 I/O 设备，可以使用一组称为设备驱动程序的操作系统服务来处理 I/O 底层
操作，封装设备接口的物理细节，达到方便访问和使用设备的目的

逻辑上讲屏幕的处理分成两个独立的模块，图形输出处理和字符输出处理

## 图形输出

绘制像素，现今的大多数计算机使用**光栅**显示技术，在位图屏幕中所能执行的唯一基本操作就是绘制一个像素，即在屏幕上绘制用行、列
坐标指定的点。一般来说，列是从左至右开始计数，即常用的 x 轴方向，而行是从上往下计数与常用的 y 轴方向相反，屏幕的最左上角的
坐标是(0,0)

在底层进行像素绘制的是属于硬件操作，它依赖于屏幕和显卡接口的具体细节，如果屏幕接口是基于 RAM 驻留内存的内存映像进行构建的，
那么将适当的二进制值写入到内存中代表该像素的内存单元，就可以完成画像素的任务

## 绘制线条

要在位图屏幕上的两个位置之间画一条线，最好的方法就是用一系列的像素来逼近连接两点之间的那条理想的直线。注意绘制所用的笔仅能沿四个方向
移动，分别是上、下、左、右四个方向，因此画出来的线并不真的平直，而是曲折不平的。要让画出来的直线看起来平直一点，唯一的办法就是使用
更高分辨率的屏幕。人眼的视网膜中的图像也是由像素网格组成，因此人眼能够分辨的图像粒度也是有限的，于是高分辨率的屏幕和打印机就能够
欺骗人眼

## Jack OS 规范详述

Jack OS 也被看作是 Jack 程序语言的扩展

Jack 操作系统由如下 8 个类组成

- Math 提供基本的的数学运算

- String 实现字符串 String 类型和字符串相关操作

- Array 实现数组 Array 类型和数组相关操作

- Output 处理屏幕上的文本输出

- Screen 处理屏幕上的图像输出

- Keyboard 处理键盘的用户输入

- Memory 处理内存操作

- Sys 提供于程序执行相关的服务

## 实现

OS 中的有些类可能需要初始化，比如对于某些数学函数，如果能够利用上之前计算的结果，运行速速就会更快。
这些值可以保存在静态数组里，该数组只用被初始化一次就可被 Math 类中所有程序共用。通常，在需要为 OS 类 XXX 编写
一段初始化代码时，应该将这段初始化代码封装到名为`XXX.init()`的函数中

## Memory

Memory.peek(), Memory.poke()这两个函数提供对底层内存的直接访问，这如何用高级语言完成呢，实际上 Jack 语言包含一个
后门，使程序员能获得计算机内存的完全控制权，通过简单的 Jack 编程，可以利用这种黑客技巧实现 peek 和 poke 函数

该技巧的实质是以非常规的方式来使用应用变脸(即指针)，Jack 语言并没有禁止程序员将常数赋给指针变量，因此该常数被当作是内存的绝对
地址。当该地址恰好是某个数组的基地址时，这种手法就能奏效，使得对整个计算机的内存进行方便和直接的访问成为可能

Jack 语言在编译期间并不从堆中为数组分配空间，而是在运行期间，当数组的 new 函数被调用时才进行内存空间分配。然而 new 函数的
初始化无法达到目的，因为整个技巧的关键是要将数组定位在一个特定的地址上，而不是让 OS 在堆中为其分配一个我们无法控制的地址

## Sys

要知道操作系统本身是一个程序，所以当计算机启动时，首先开始运行的是操作系统程序，而且是操作系统的主程序

## 观点

本章提供的软件程序包含了多数操作系统里的一部分基本服务，如内存管理、I/O 驱动、初始化处理、提供没有在硬件中实现的
数学函数，以及实现诸如 string 抽象之类的数据类型

本书将这个标准库称为操作系统，以此来反应其主要功能，即将繁琐的硬件细节和硬件特性封装到透明的软件包中，使得高层程序
员能够通过简单的接口来使用它提供的服务

作为十分初级的操作系统，Jack OS 还缺少一些与操作系统最紧密相关的基本功能。比如我们的 OS 不支持多线程，也不支持并行处理，
相比之下，大多数操作系统的关键任务就是要支持这些功能。

我们的 OS 也没有大容量存储设备，其他操作系统处理的是文件系统抽象，我们的 OS 既没有命令行接口(如 Unix Shell 和 Dos 窗口)，
也没有图形化接口，这些都是用户期望的操作系统应该具备的功能。很多其他的常见服务也没有，比如安全机制、通信机制等
