# 汇编编译器

1 章到 5 章描述并构建了计算机的硬件平台，6 章到 12 章论述计算机的软件阶层体系，直到最后为简单的面向
对象编程语言开发编译器和操作系统

在软件阶层体系中，最基本的模块就是汇编编译器(assembler)，在第 4 章中介绍了机器语言的两种表现形式，即汇编形式和
二进制形式。本章将介绍编译器如何系统地将汇编语言编写的程序翻译成二进制形式

因为符号化汇编命令与其对应的二进制代码之间的关系是很简单的，所以编写汇编编译器(使用某种高级语言编写)并非是
很难的任务。唯一的复杂性在于，允许汇编程序使用符号来指代内存地址。我们希望编译器来管理这些用户定义的符号，将
它们解析成物理内存地址，一般可以使用符号表来完成这个任务，这种符号表是经典的数据结构，应用在很多软件编译过程中

Hack 汇编编译器不是软件层级的终极目标，但它为任何汇编编译器的构建过程中关键的软件工程原则提供了简单明了的示范

现代计算机平台支持很多基础操作，如此一来，机器语言会变得相当复杂，因为设涉及很多操作码、不同的内存寻址模式和不同的
指令格式。解决此复杂性的方法之一是，使用约定的语法来表示机器指令，例如 `LOAD R3,7`而不是`11000....`来表示机器语言。
由于将符号表示翻译成二进制码是直接了当的，所以允许用符号表示法来编写底层程序，并用计算机程序将底层程序翻译成二进制码

符号化的语言称为汇编(assembly)，翻译程序被称为汇编编译器。会编译器对每个汇编命令所有部分进行解析，将每个部分翻译成
它对应的二进制码，并将生成的二进制码汇编成真正能被硬件执行的二进制指令

符号在汇编程序通常有两个用途

**变量** 程序员可以使用符号的变量名称，翻译器会自动地为其分配内存地址。需要注意的是，这些地址的实际值是没有
意义的，只要在程序的整个编译过程中，每个符号始终被指代为同一地址

**标签** 程序员可以在程序中用符号来标注不同的位置，例如，可以用标签 loop 来指代特定代码段的起始地址，程序中的其他
其他命令可以有条件或无条件地执行 goto loop 指令

用户定义的变量名称和符号标签与实际内存地址的映射则不是那么简单，事实上，这个确定符号地址的任务是从硬件层级上升到
软件层级过程中遇到的第一个挑战

编程语言支持多种类型变量，它们在目标计算机上占用不同的内存空间。比如，C 语言数据类型 short 和 double 分别代表 16 位和 64 位
数字。当 C 程序在 16 位机器上运行时 short 变量将占用 1 个单独的内存单元，long 变量将占用 4 个连续单元组成的块。因此，当为
变量分配内存空间时，翻译程序必须考虑它们的数据类型和硬件内存单元的宽度

## 汇编编译器

汇编程序在被计算机执行之前，必须被翻译成计算机的二进制机器语言，翻译任务是由称为汇编编译器的程序来完成，汇编编译器的输入
是一串汇编命令，然后产生一串等价的二进制指令作为输出。生成的代码被加载到计算机的内存中然后被硬件执行

可见，汇编编译器实际上主要是个文本处理程序，设计目的是用来提供翻译服务，编写汇编编译器的程序员必须有完整的汇编语法说明文档和
相应的二机制代码。有了这样的约定，就不难编写

- 解析出符号命令内在域

- 对于每个域，产生机器语言中相应的位域

- 用内存单元的数字地址来替换所有的符号引用

- 将二进制码汇编成完整的机器指令

其中三个任务，解析、代码生成和汇编是相当容易实现的，而符号处理相对较为复杂

## Hack 汇编到二进制的翻译规范

**文件名称**

习惯上，二进制机器代码表示的程序被存储在后缀为`.hack`的文本文件中，汇编代码表示的程序被存储在后缀为`.asm`的文本文件中

**二进制代码文件**

二进制代码文件由文本行组成，每一行由 16 个`0/1`组成的 ASCII 码构成一个序列，该序列对一个单一的 16-位机器语言指令进行编码。
文件中的所有行在整体上代表一个机器语言程序，当机器语言被加载进计算机的指令内存中时，文件中的第 n 行二进制码被存储到地址为 n 的
指令内存单元内

**汇编语言文件**

汇编语言文件由文本行组成，每一行代表一条指令，或者一个符号声明

**指令** A-指令或 C-指令

**Symbol** 该伪命令将 Symbol 绑定到该程序中下一条的地址上，因为它并不产生机器代码

**常数和符号** 常数必须是非负的，用十进制表示。用户定义的符号可以是由字母、数字、下划线、
点、美元符号、冒号组成的字符序列，但不能以数字开头

**注释** 以两条斜线(//)开头的文本行被认为是一条注释，注释不会被计算机执行

**空格** 空格字符和空行被忽略

**大小写习惯** 所有的汇编助记符必须大写，一般的习惯，标签大写，变量名称小写

## 符号

Hack 汇编命令通过使用常数或符号来指代内存单元，汇编程序中的符号来源于三个方面

预定义符号，标签符号，变量符号

## 实现

我们提出一个基于 4 个模块的会编译器的实现，**语法分析器模块**用来对输入文件进行语法分析，**编码模块**用来提供所有
汇编命令对应的二进制代码，**符号表模块** 用来处理符号，另外还有一个主程序用来驱动整个编译过程

汇编编译器的开发是 5 个软件构件项目中的第一个，也是构建翻译器层级中的第一步

在某些语言中，模块可被显式地表示，而在其他一些语言中则被隐式地表示(比如 C 语言中的 file)，在另一个语言中，模块没有
相应的语言结构，它仅仅代表在概念上对程序进行分组

## 语法分析器

语法分析器的主要功能是，将汇编命令分解为其所表达的内在含义。

汇编程序允许在符号被定义之前使用符号标签，此功能为汇编程序员带来极大的便利，却使得汇编编译器开发者的工作变得更复杂。
解决这个问题的方法之一是，编写两遍汇编编译器，从头至尾地读取两次代码。

第一遍读取时，汇编编译器构建符号表但并不产生代码。第二遍读取时，程序中遇到的所有标签符号所对应的内存地址都已经
被记录在符号表中了，这个符号表就是编译器在第一次读取程序的过程中建立的。因此，汇编编译器能用每个符号相关的含义来
替换该符号，并产生最后的二进制码

Hack 语言中有三种类型的符号，预定义符号、标签和变量，符号表应该包含并处理所有这些符号

**第一遍阶段**

该阶段主要是在符号表中建立每条命令及其对应的地址。逐行处理整个汇编程序，构建符号表而不生成任何代码，
处理程序的每一行时，利用数字来记录 ROM 地址- 当前命令最终将被加载到这个地址中，这个数字从 0 开始。不管碰到
C-指令还是 A-指令都自动加 1，但是当遇到标签伪指令或注释时不发生变化，每次遇到一条伪指令(Xxx)时，在符号表上加
一个新条目将 Xxx 与最终用于存储程序中下一条指令的 ROM 地址关联起来。这个阶段程序中所有的标记和它们的 ROM 地址被加入
到符号表中，程序的变量放在第二阶段处理

**第二遍读取阶段**

现在重新对整个程序进行处理，对每一行进行语法分析。每次遇到符号化 A-指令时，即@Xxx 指令中 Xxx 是符号而不是数字时，
就在符号表中查找 Xxx。如果在符号表中找到了该符号，就用其对应的地址来替换该符号以完成命令的翻译。如果在符号表中没有
找到该符号，那么它必定代表变量，为了处理这个变量，就在符号表中添加(Xxx, n)，这里 n 代表下一个可使用的 RAM 地址。
分配的 RAM 地址是连续数字

这样，汇编编译器的实现过程就完成了

## 观点

跟大多数汇编编译器一样，Hack 汇编编译器是相对简单的程序，主要用于处理文本处理，显然，较丰富的机器语言的汇编编译器
相对复杂，一些汇编编译器会具有 Hack 所缺乏的更好的符号处理能力。比如，这些汇编编译器可以允许程序员将符号与特定的
数据地址联系起来对符号执行常数运算等等

Hack 汇编编译器可以扩展能将约定的宏命令，`D=M[xxx]` 翻译成两个指令 `@xxx` 和 D=M，显然，这样的宏命令能够在相当
程度上，以较低的翻译代价来简化涉及常用操作的程序编写

需要注意的是，单独的汇编编译器很少在实际中用到，人们很少编写汇编程序，这主要有编译器来负责。编译器是自动机，它不必为生成
符号的命令而费心。

很多高级语言编译器允许程序员在高级程序中嵌入汇编语言代码部分，这个功能在 C 语言编译器中相当普通，它让程序员能直接
控制底层硬件以达到优化的目的

## 项目

开发汇编编译器，将用 Hack 汇编语言编写的程序翻译成 Hack 硬件平台能够理解的二进制代码

完成这个项目所需的唯一工具就是用来实现汇编编译器的编程语言
