# 编译器: 代码生成

现在高级编程语言是十分丰富和强大的，它可以定义和使用大量的数据抽象，比如对象和函数，可以实现包含精巧流程
控制语句的算法，还可以构建具有任意复杂度的数据结构。然而这些程序所最终运行的目标平台则很简单，一般它们仅仅
提供一组用于存储数据的寄存器，和用于处理数据的原始指令集。

将程序从高级语言翻译到低级语言是个有意义的难题，如果目标平台是虚拟机，那么事情就简单一点，但是高级语言的表示
和虚拟机的表示之间的差距仍然很大

程序本质上就是一系列操作数据的操作，因此，将高级程序编译成低级语言主要涉及两个主要的问题：数据的翻译和命令的翻译

完整的编译任务是指将高级程序最终翻译成二进制代码，既然我们介绍的是双层的编译器架构，那么本章要假定编译器是要生成
VM 代码。

## 数据翻译

程序能操纵很多变量类型，包括整型和布尔型等简单的类型，以及数组和对象等复杂类型。另一个需要讨论的重要内容是
变量的生命周期和作用域，即局部变量、全局变量、参数、对象成员字段等等

对于程序中遇到的每个变量，编译器必须将其映射到目标平台中适合描述其类型的等价表示上。此外，编译器必须管理变量的
生命周期和作用域，这与它的类型相关。

高级程序引入并操纵很多标识符，当编译器遇到标识符`xxx`时，它需要知道`xxx`代表什么，它是变量名、类名、还是函数名。
如果它是变量，那么`xxx`是某个对象的成员类型，还是某个函数的参数。变量的种类又是什么，整数、布尔数、字符或某种数据
类型。在编译器能用目标语言表达`xxx`的语义之前，必须解决这些问题

## 变量处理

编译器所面对的基本挑战之一是，如何将源程序中声明的各种变量类型映射到目标平台的内存中去。首先，不同的变量类型需要不同大小的
内存块，因此这种映射不是一对一的，其次不同的变量有不同的生命周期

例如，应该在程序整个运行期中保持每个静态变量的单一副本，相比之下，对于对象的所有实例变量，类的每个对象实例都应该保存有其各自
的副本。在清除对象时，应该收回其内存。同样，每次调用子程序时，必须为其局部变量和参数创建新的副本

在双层编译架构中，变量的内存分配任务交给了 VM 后端程序。虚拟机包含了标准类型变量的存储机制，这些标准变量类型包括，静态变量、
局部变量、参数变量以及对象的成员字段，它们都是大多数高级语言所需要的。通过使用全局堆栈和虚拟内存段，这些变量的所有分配和去配
细节已经在 VM 层被处理了

VM 将全局堆栈和虚拟内存段映射到最终的硬件平台上，然后付出的努力是值得的，对于任何给定的语言 L，`L-VM`编译器现在都已经完全从
复杂的底层内存管理中解脱出来了

## 数组处理

数组几乎总是被存储在连续的内存单元组成的内存段中，多维数组将被转化为一维数组，数组的名字通常被当作是指针

有一些语言，声明数组时，用于存储该数组的整个内存空间被一次性分配。而其他一些语言比如 Java，数组的声明仅仅只会分配一个指针，
该指针指向数组内存段的基地址，只有在程序运行期间该数组被真正构造时，才会被分配合适的内存段。这是从内存堆中经由动态内存分配
得到的内存段

而动态内存分配是通过调用操作系统的底层内存管理程序实现的，操作系统有典型的`alloc(size)`函数，它知道如何找到可用大小为
size 的内存块，并返回它的基地址给调用者

当编译器编译诸如`bar=new int[10]`这样的高级语句时，它生成执行操作`bar=alloc(10)`的低级代码。该代码导致将数组内存块的基
地址赋给 bar，着正是我们所期望的

## 对象处理

某个类的对象实例封装了数据项以及一组操纵它们的操作。编译器对数据和操作的处理方式是完全不一样的

对数据的底层处理方式与数组的处理方式很相似，也是在连续的内存段中存储每个对象实例，在大多数面向对象语言中，当一个类型变量被
声明时，编译器也仅分配一个指针变量。只有通过调用类构造函数来真正构建对象时，才给它分配所需的内存段

当编译某个类`xxx`的构造函数时，编译器首先利用类成员的数量和类型来决定在内存中需要多少个字来存储类`xxx`的一个对象实例。接下来，
编译器生成为新创建对象分配内存的代码，例如`this=alloc(n)`。该操作将 this 指针设置为表示新创建对象所在内存段的基地址

对于数据变量，每个实例都保存了各自副本，然而对于类中的方法，它在目标代码层只存在唯一副本，即所有该类的对象实例都共同一个方法副本。
编译器必须保证这个唯一的方法副本能够对任意对象实例进行方便的操作。这就需要将被调用方法的引用作为隐含参数传递给对象实例

在编译`b.mult(5)`时，就好像它被写成了`mult(b, 5)`

一般来说，对方法的调用`foo.bar(v1, v2,...)`被翻译成 VM 代码:

```
push foo,
push v1,
push v2,
...,
call bar
```

这样编译器就能使得同一个方法副本可以操作任何对象实例，并且形成每个对象实例都封装了全部代码
然而，编译器的工作并没有完成，因为语言允许在不同的类中的不同方法具有相同的名字，所以编译器必须确保对应的方法被应用
在对应的对象上。而且因为在子类中可能出现方法重载，面向对象语言的编译器必须在程序运行期间来确定

如果不支持以上操作，例如 Jack 语言，那就在编译期间来确定，对于如`x.m(y)`的方法调用，编译器必须保证调用的方法`m()`属于
对象实例 x 所属的那个类

## 命令翻译

现在来描述高级命令是如何被翻译成目标语言的，因为已经讨论了变量、对象和数组的处理，所以现在只有两个两个问题需要讨论，
表达式求值和程序流程控制

## 虚拟机平台之上的标准映射

- 在 Jack 程序中，类 yyy 中的 Jack 子程序 xxx()被编译成名为 `yyy.xxx()`的 VM 函数

- 拥有 k 个参数的 Jack 函数或构造函数被编译成对 k 个参数进行操作的 VM 函数

- 拥有 k 个参数的 Jack 方法被编译成对 k+1 个参数进行操作的 VM 函数，第一个参数(参数 0)总是指针 this

## 内存分配和访问

- Jack 子程序的局部变量被分配到 local 虚拟段，并通过该段对其进行访问

- Jack 子程序的参数变量被分配到 argument 虚拟段，并通过该段对其进行访问

- `.jack` 类文件的静态变量被分配到相应的`.vm`文件的 static 虚拟段，并通过该段对其进行访问

- 在 Jack 方法或构造函数相应的 VM 函数中，要想访问 this 对象的字段，首先通过使用`pointer0`来将以 this 指针的虚拟内存段映射
  为存储当前对象的内存段上，实际上就是使 this 指针指向存储当前对象内存段的基地址，然后通过 this index 来访问对象中的各个成员，
  这里 index 是非负数

- 在 VM 函数中，要想访问数组的数据项，同访问对象的方法相似，首先通过使用`pointer1`使得 that 指针指向数组的第一个元素，然后通过
  that 指针来访问数组中的数据项

## 子程序调用

- 在调用 VM 函数之前，调用者必须将函数的参数压入堆栈。如果被调用的 VM 函数是 Jack 方法，那么首先压入的参数必须是该方法
  操作对象的引用

- 将 Jack 方法编译成 VM 函数时，编译器必须插入适当的 VM 代码来设置 this 虚拟段的基地址。同样，在编译 Jack 构造函数时，
  编译器也必须插入 VM 代码，该代码为新对象分配一个内存段然后将 this 指向这个内存段的基地址

## 从返回类型为 Void 的方法及函数返回

高级 void 子程序并不返回值，这个抽象按如下方法来处理

- 返回类型为 void 的方法和函数所对应的 VM 函数必须返回常数 0 作为其返回值

- 编译 do sub 语句时，sub 是返回类型为 void 的方法或函数，对应的调用者必须弹出该返回值

- null 和 false 被映射到常数 0，true 被映射到常数 -1

## 使用操作系统服务

- 乘法和除法由 OS 函数 Math.multiply()和 Math.divide()来处理

- 字符串常数由 OS 构造函数 String.new(length)来创建

- 构造函数利用 OS 函数 Memory.alloc(size)来为新的对象分配空间

## 观点

Jack 是一门相对简单的编程语言，这个事实回避了几个让人头疼的编译问题，例如 Jack 看上去像是一种带类型的语言，
然而事实并非如此，所有 Jack 数据类型都是 16-位长的，当编译和计算表达式时，Jack 编译器不需要确定它们的类型。

大多数编程语言都具有丰富的类型系统，并对其编译器产生重要影响，对于不同类型的变量必须分配不同的数量的内存。从一种类型到
另一种类型的转换需要特定的语言操作，诸如`x+y`的简单表达式的操作，很大程度上依赖于 x 和 y 的类型

另一个重大简化是 Jack 语言没有支持继承，这意味着可以在编译期静态地处理所有方法调用。相比之下支持继承的语言编译器必须将
方法作为虚拟方法对待，并根据对象的运行期类型来确定它们的具体位置

Jack 所不支持的另一种面向对象的重要属性是公共类成员字段(public class fields)

因为缺少对类型、继承和公共成员的支持，所以各个类在编译过程中可以独立地进行编译而无需考虑其他类成员

## 项目

Jack OS 是用 Jack 语言编写的，OS 源代码通过完整的 Jack 编译器被翻译成一组 VM 文件，这组文件就是 Jack OS。想要在 VM
在 VM 仿真器上运行应用程序，不经要加载应用程序的`.vm`文件，还要加载 OS 的所有`.vm`文件。当应用级的 VM 函数通过调用某个
OS 级的 VM 函数时，它们会在相同的环境下找到对方
