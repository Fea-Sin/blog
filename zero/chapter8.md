# 虚拟机 II: 程序控制

本章继续阐述 VM 抽象、语言和实现的开发，我们要阐述如何设计基于堆栈的机器，以及用它来处理过程化语言或
面向对象的语言的嵌套子程序调用。

在计算机科学领域的竞赛中，堆栈处理绝对是进入决赛的强大选手，前面的章节已介绍算术表达式和布尔表达式是如何
利用基本堆栈操作来进行计算的。
本章将继续介绍这个简单的数据结构如何支持像嵌套子程序调用、参数传递、递归和内存分配技术这样复杂任务，大多数程序员
不希望在这些功能上花功夫，而指望编译器来帮他们实现

高级语言支持这种表达式来源于它的三种语言原则，首先高级语言允许在程序中根据需要自由定义如`sqrt`和`power`这样的高级操作。
其次高级语言允许自由调用这些函数，就像使用如`+`和`*`这样的基本操作一样。最后高级语言允许假设每个调用的子程序都会
被执行，并且随着子程序的结束，程序的控制权限顺利返回

高级语言所具有的这种能将表达式自由组合的能力使得我们可以编写抽象代码，让我们能把精力主要放在算法的思想上，而不是机器的
执行上。当然高级语言抽象级别越高，在底层要做的工作也越多。特别是，必须在底层控制`子程序`和`子程序调用者`之间的互相影响，
执行诸如`sqrt`和`power`的系统定义和用户定义操作的程序单元之间的相互影响

在运行期的每个子程序调用，底层必须处理下面的一些细节

- 将参数从调用者`caller`传递给被调用者`called subroutine`

- 在跳转并执行被调用者之前，先保存调用者的状态

- 为被调用者使用的局部变量分配空间

- 挑战并执行被调用者

- 将被调用者的运行结果返回给调用者

- 在从被调用者返回之前，收回其使用的内存空间

- 恢复调用者的状态

- 返回到调用语言之后的下一条语句继续执行

要考虑这些琐碎的事情是很头疼的，好在编译器把高级语言程序员从中解脱出来。那么编译器是如何做到这些的呢

堆栈机(stack machine) 可以处理这种类似任务，本章将描述程序控制流命令和子程序调用命令是如何在堆栈机上
实现的

## 程序控制流

计算机程序默认的执行顺序是线性的，即一个命名接着一个命令执行，这个连续的控制流偶尔被分支命令打断。
在底层编程中，分支逻辑利用`goto destination`命令实现，该命令让计算机跳转到程序中由目标参数指定的位置
继续执行。

目的地址的指定方式可以有多种形式，最原始的一种就是指定即将执行的指令的物理地址。应用标签 label 来描述 jump 的
目的地址可以建立稍微抽象一点的重定向命令，这种改进需要程序语言配有标签指令，它可以将标签绑定到程序中指定的位置

这种基本的 goto 机制也可以很容易地实现条件分支，比如`if-goto destination`命令可以指示计算机仅在`给定的布尔条件为真`
的情况下执行跳转

我们如何把布尔条件判断引入程序语言中呢？在堆栈中，最常见的方法是根据堆栈栈顶元素的值来判断是否进行跳跃，如果它非 0，
那么计算机就跳转到程序中指定的位置，否则就继续执行程序中的下一条命名

VM 的原始操作是如何计算任意给定的布尔表达式的，并将其结果置于栈顶。这种布尔表达式于刚才介绍的 goto 和 if-goto 命名
相结合，就可以表示任何编程语言中的任何控制结构的流程

VM 命令 label、goto label、if-goto label 的底层实现是很容易的。所有的编程语言都有某种分支命令结构。如果底层实现
是基于将 VM 命令翻译成汇编代码，那么我们所要做的就是利用汇编语言的分支逻辑来重新表达 goto 命令

## 子程序调用

每种编程语言都有的特征是具有一组固定的内置命令集合。现代编程语言抽象机制的关键是允许程序员应用自定义的高级操作自由地
扩展该语言的基本指令集。在过程化语言中，高级操作称为子程序、过程或者函数，在面向对象的语言中，它们通常称为方法。
所有这些高级程序单元都是指子程序

在优秀的编程语言中，高级操作(利用一个子程序来实现)的使用于使用语言本省自带命令的感觉一样。例如对于两个功能`add`和
`raise to power`大多数语言把前者作为内置操作，后者可能会作为子程序来编写。尽管它们的实现是有区别的，但是对于
调用者而言两个函数都应该以统一的方式被调用

调用内置命令和调用用户定义的子程序的唯一区别是用户定义子程序之前要有关键字`call`，除此之外，内置命令和用户自定义
子程序实现过程都是一样的，两者都需要调用者将参数传递给被调用者，被调用者从堆栈中取出参数，在被调用者结束时将其
处理结果压入堆栈返回给调用者

子程序通常都会使用局部变量进行临时存储，在子程序的生命周期中，也就是从子程序开始执行直到遇到`return`命令为止，
必须为这些局部变量分配内存。在子程序返回时，这些被局部变量占用的内存将被释放。当允许子程序被任意嵌套时，子程序
的调用机制会变得很复杂，一个子程序可以调用另一个子程序。不仅如此，被调用的子程序还可以进一步调用其他子程序，如此嵌套。
而且，还允许子程序递归地调用自己，每个递归调用必须独立于其他调用，并且维护自身的局部变量和参数。那么如何才能实现
这种嵌套机制以及相关的内存管理机制呢

调用和返回逻辑的线性嵌套分层特点让这个繁琐任务变得容易管理，虽然子程序调用可以具有任意深度，可以有任意的递归，
但是在任何时刻，只有调用链顶部的子程序才能被执行，而处于调用链中其他子程序将一直等待到该子程序执行完毕为止才
能继续执行。

在子程序调用的实现过程中，这种后进先出的处理方式和堆栈数据结构的操作方式完全吻合

当子程序 xxx 调用子程序 yyy 时，可以将 xxx 的环境变量压入堆栈中，然后转去执行 yyy，当 yyy 返回时，再将 xxx 的环境变量
从堆栈中弹出，如果没有特殊的情况出现就继续执行 xxx

在所有调用子程序的过程中，调用者的返回地址没有显式地给出。比如像`power(x,y)`或`sqrt(x,y)`这样的子程序可以被
任何调用者调用，那么他们的代码就不可能给出具体的返回地址。`return`命令应该按如下方式来解释：它将程序的执行重定向
到语句 call 命令的下一条命令所在的内存地址，即称为`返回地址`

当我们用`call xxx`指令执行调用操作时，应该知道准确的返回地址，指令`call xxx`的下一条指令的内存地址。因此，我们
将该指令内存地址作为返回地址压入堆栈保存，然后去执行子程序，当我们最终遇到 return 命令时，我们就将先前保存在堆栈中
的返回地址弹出来，然后只用简单的 goto 命令跳转到这个地址就可以了

## 程序控制流命令

VM 语言有三种形式的程序控制流命令

- label 该命令标记程序中某条指令的位置，在程序中的跳转指令只能跳转到被 label 命令所标示的位置，label 标签所指示
  的代码段范围就是程序中定义的函数体

- goto label 该命令执行无条件跳转操作，使得程序跳转到 label 命令标示的位置那里继续执行，跳转目的地址必须位于同一个
  程序之内

- if-goto label 该命令执行跳转操作，首先将布尔表达式的运算结果从堆栈顶端弹出，如果该值非 0，那么程序就跳转到 label 标示
  的位置继续执行，否则继续执行程序中的下一条命令，跳转的目的地址必须位于同一个函数内

## 函数调用命令

不同的高级语言对于程序单元概念采用不同的名称，包括函数、过程、方法以及子程序，在整个编译模型中每个高级程序单元都被
翻译成 VM 函数

函数的名称是个全局量，函数名称的使用范围是全局的，即所有文件中的所有函数可以通过这种全局名称互相调用

VM 语言有三种函数相关的命令

- function f n，函数名为 f 的代码，该函数有 n 个参数

- call f m，调用函数 f，其 m 个参数已经被调用者压入堆栈

- return 返回到调用者

## 函数调用协议

调用函数和从函数返回这两个操作可以从两个不同的角度来看

**调用者的角度**

在调用函数之前，调用者必须将必要的参数压入堆栈，接着调用者使用 call 命令来调用函数，被调用函数返回后，调用者先前
压入堆栈的参数将被删除，并且函数的返回值将出现在栈顶
被调用函数返回后，调用者的各内存段`argument`,`local`,`static`,`this`,`that`和`pointer`跟调用之前一样，
temp 未被定义

**被调用者角度**

当被调用的函数开始执行，其`argument segment`段被初始化为调用者所传递的参数，为其 local segment 段分配内存空间
并初始化为 0，它的`static segment`段被置为其所属 vm 文件中的`static segment`，工作堆栈为空，`this, that, pointer, temp`四个指针均未初始化

返回前被调用函数必须将某个值压入堆栈

VM 函数开始运行时，要保证其处于自己的私有空间之内，这个私有空间是由各函数的虚拟内存和地址组成。VM 函数的指令就对其私有
空间内的各个虚拟内存段和堆栈进行操作，VM 实现机制负责构建各 VM 函数的私有空间

## 初始化

VM 程序是一组相关的 VM 函数集合，一般来自于某种高级程序的编译，当 VM 实现开始运行时，按照惯例它总是执行名为`Sys.init`
的无参数 VM 函数，接着该函数调用用户程序中的主函数，因此，生成 VM 的编译器必须保证每个翻译后的程序都有个这样的`Sys.init`函数

## 全局堆栈

VM 的内存资源是通过维护一个全局的堆栈来得到的，每当调用一个函数时，该函数对应的帧就被压入全局堆栈，该帧包括被调用函数将要
使用的参数，一组用于保存调用者状态的指针(pointers)，被调用函数的全局变量，以及一个被调用函数将要使用的工作堆栈

ARG、LCL 和 SP 指针对于 VM 函数是不可见的(无法感知存在)，这三个指针是更底层的 VM 实现在函数调用与返回协议中使用的

## 汇编符号

程序控制流命令和函数调用命令的实现需要 VM 实现在汇编语言层面创建并使用特殊符号

## 引导程序代码

当 VM-Hack 翻译器编译 VM 程序时，会产生一个用 Hack 汇编语言编写的`.asm`文件，该文件必须符合规范。
标准映射规定：VM 堆栈的初始地址必须映射到 RAM[256]
经编译后的 VM 程序所执行的第一个 VM 函数必须是`Sys.init`

Sys.init 将调用主程序的主函数，然后进入无限循环，这样翻译后的 VM 程序就进入运行状态

程序、主程序、主函数的概念与编译过程又关，在不同的高级语言中它们的概念并不相同。在 Jack 语言中，默认的是自动开始
运行的第一个程序单元就是 Main 类中的 main 方法。同样当 JVM 去执行给定的`Foo`类时，JVM 会去寻找并执行`Foo.main`
方法。通过正确的编写 Sys.init 每种语言编译器都能执行这样的`自动`启动程序

## 观点

子程序调用和程序流程控制的概念对于所有高级语言都是很基本的，这意味着在将程序换成二进制代码过程中的某些地方，必须考虑预期实现
相关的一些复杂操作。在 Java、C#和 Jack 中，这个任务落在 VM 层上。如果 VM 是基于堆栈的，就能很好地解决这些复杂问题
