# 机器语言

机器语言是整个计算机体系中意义最深奥的接口，它也是硬件和软件相接的中间线。借由机器语言，程序员用符号表达的
抽象思维被转换成执行在硅片上的物理操作。

即可以将机器语言看作编程工具，也可以将其看作硬件平台内部不可分隔的一部分，事实上，正如我们设计机器语言是为了
使用给定的硬件平台一样，我们设计硬件平台是为了获取、解析并执行用给定机器语言编写而成的指令

虽然大多数人以后永远不会直接用机器语言来编写程序，但是学习底层软件是彻底理解计算机体系的必备条件

最复杂的软件系统，在底层其实是一长串基本指令，每一条指令都描述了底层硬件上的一些极为简单而原始的操作

**机器语言**可以被看作是一种约定的形式，它利用处理器和寄存器来控制内存

**内存**的概念是指用来存储数据和指令的硬件设备，从程序员的观点来看，所有的内存具有相同的结构，一个连续的固定
宽度的单元序列，也称为字或内存单元，每个内存单元都有一个唯一的地址。因此，对于独立的字代表一个数据项或是一个指令，
可以通过提供它的地址来描述

## 处理器

处理器通常又称为中央处理器 cpu，是执行一组固定基本操作的设备，这些操作通常包括算术操作和逻辑操作，内存存取操作和控制
操作，这些操作的对象是二进制数值，它们来自寄存器和指定的内存单元。操作的结果既可以存储在寄存器内，也可以存储在指定的
内存单元

**寄存器** 内存访问是相对较慢的操作，需要很长的指令格式，一个地址可能需要 32 位。因此，大多数处理器都配有一些寄存器，
每个寄存器只存储 1 位，它紧挨着处理器，相当于处理器的一个高速本地内存，使得处理器能快速地控制数据和指令。

## 机器语言

机器语言程序是一些列的编码指令，比如在 16-位计算机上的经典指令之一是`1010001100011001`，知道这个指令的意思，就必须知道
语言的规则，也就是底层硬件平台的指令集。这样的指令包含四个 4 比特位位域(fields)，最左边的域是 CPU 的操作编码，剩下的三个
部分表示该操作的操作数

鉴于二进制码相当晦涩，通常会在机器语言中同时使用二进制码和助记符。助记符是一种符号标记，它的名字暗示了其所代表的意思，硬件元素
和二进制操作
例如，语言设计者可以定义操作码 `1010` 用 add 来表示，机器中的寄存器可以使用符号 R0、R1、R2 等来表示

将这种符号抽象更进一步发展，我们不仅能够阅读符号表示，而且能实际地利用这些符号命令而不是二进制指令来编写程序。接下来可以使用
文本处理程序，将这些符号命令解析为其内含的意域，将每个意域翻译成其对应的二进制表示，然后将生成的代码汇编成二进制机器指令。
符号表示也称为汇编语言，而将汇编程序翻译成二进制码的程序则称为汇编编译器

因为不同的计算机在 CPU 的操作方式、寄存器的数量和类型，以及汇编语法上各不相同，就像机器语言的巴别塔，每种计算机都有它自己的
晦涩语法，所有的机器语言都支持相似的通用命令集合

**算术操作和逻辑操作**
基本的算术操作，比如加法和减法。逻辑操作，按位取反、移位等等

`ADD R2,R1,R3` R2 <- R1 + R3，R1、R2、R3 是寄存器

`AND R1,R1,R2` R1 <- R1 和 R2 进行按位与

## 内存访问

内存访问命令分为两类，第一类，算术命令和逻辑命令不允许操控寄存器

第二类，计算机使用 load 和 store 命令在寄存器和内存之间传递数据，这些访问命令可能会应用某些类型的寻址
方式，并在指令中指定目标内存单元的地址

大多数计算机支持的寻址方式

**直接寻址** 最常用的寻址方式，直接表示一个指定内存单元的地址，或者使用一个符合来代表这个指定的地址

`LOAD R1,67` R1 <- Memory[67]

**立即寻址** 这种寻址方式被用来加载常数，也就是说，那些出现在指令代码里面的数值，我们直接将指令数据域中的
内容当作要操作的数据装入寄存器，而不是将该数值当作内存单元的地址

`LOADI R1,67` R <- 67

**间接寻址** 这种寻址模式中，要访问的内存单元的地址没有直接出现在指令中，而是指令指定的内存单元中的内容代表
目标内容单元的地址。这种寻址被用来处理指针

例如，一条高级语言命令 x=foo[j]，这里 foo 是数组变量，x 和 j 是整数变量，那么与这条命令等价的机器语言是什么呢
当数组 foo 在高级语言程序被声明并被初始化时，编译器分配一组连续的内存单元来保存这个数组数据，并用符号 foo 来指代该
内存单元组的基地址

于是当编译器后来遇到表示数组单元的符号 foo[j]时，将按以下步骤进行地址解析。
j 个数组入口是某个内存单元的物理地址，该地址相对于数组基地址的偏移量为 j，表达式 foo[j]相关的地址可以很容易地被计算出来，
即只需将 foo 的值加上 j 即可。在 C 程序语言中 x=foo[j]这样的命令也可以等价地表示成 `x=*(foo+j)`这里的`*n` 代表
`Memory[n]的值` 被翻译成机器语言时，这样的命令根据特定的汇编语言的语法，会产生如下的代码

```
// x = foo[j]

ADD R1,foo,j // R1 <- foo+j
LOAD* R2,R1  // R2 <- Memory[R1]
STR R2,x     // x <- R2
```

## 流程控制

程序通常以线性方式，一个命令接着一个命令执行，但偶尔也包含分支，执行其他地方的命令。分支能够实现好几种结构，包括反复、
有条件的执行，以及子程序调用

为了支持这些程序结构，各种机器语言都可以有条件或无条件的跳转到程序制定的地址

无条件跳转命令，JMP beginWhile 只指定了挑转的目标地址。有条件跳转命令 JNG R1, endWhile 还必须给出确定的布尔条件。在一些语言中，
布尔条件可以通过命令显式给出，也可以隐含地由先前指令的执行结果给出

高级语言

```
// while 循环
while (R1 >= 0) {
  代码段1
}
代码段2
```

底层实现

```
// while 循环结构
beginWhile
  JNG R1, endWhile
  // 代码段1
JMP beginWhile
endWhile
// 代码段2
```
