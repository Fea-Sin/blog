# 语法分析

编译器是一种程序，能将高级语言程序从源语言翻译成目标语言，这个翻译过程即编译 compilation，从概念上讲由两个
不同的任务组成

我们必须理解源程序的语法，以此来揭示程序的语义。比如，对代码进行语法分析可得知程序想要声明数组或操纵对象。
该信息让我们能够使用目标语言的语法来重构程序的逻辑

第一个任务通常是语法分析，第二个任务即代码生成

本章将构建语法分析器，我们的方法是让语法分析器输出 XML 文件，其格式反映了输入程序的语法结构，通过观察生成的
XML 输出，应该能够确定分析器是否正确地解析了输入程序

语法分析的基本概念，词法分析、上下文无关语法、语法分析树，以及用于分析它们的递归下降算法

从零开始编写编译器是一项复杂的任务，涉及计算机科学里面很多基础主题。它需要对语言翻译和语法分析技术的理解，
需要使用树和哈希表等一些经典数据结构，需要应用一些高效的递归算法。因此，编写编译器是富有挑战的任务。

为什么要补嫌麻烦地构建编译器呢，首先，对编译过程内部原理的掌握将会使你成为更好的高级程序员。其次，用于描述
编程语言的规则和语法，同样也能用于描述不同应用(从计算机制图到数据库管理、再到通信协议，以至于生物信息)中
的数据集的语法。因此，虽然大多数程序员在编程生涯中不必开发编译器，但很有可能需要分析和处理某种复杂语法的
文件。这些任务与分析编程语言一样，采用相同的概念和技术

典型的编译器由两个主要模块组成，语法分析和代码生成

语法分析任务通常可以进一步分成两个模块，字元化模块将输入的字符分组成语言原子元素，然后由语法分析模块将所得到的
语言原子元素集合同语法规则相匹配。注意，这些行为相对于目标语言是完全独立的，本章并不涉及代码生成，我们让语法
分析器输出 XML 文件，表示程序经编译后的语法分析结构

本章集中讨论编译器的语法分析模块，其任务是理解高级源程序的结构。
人们在阅读计算机程序时，立即就能弄清程序的结构，人们能辨认类(class)和方法(method)在那里开始，到那里结束，哪些是
声明、哪些是语句、哪些是表达式，它们是怎么组织的等等。

这种理解不无价值，因为这需要具有对嵌套模式的辨认能力和归类能力，在一般程序中，类包含方法，方法包含语句，
语句包含其他语句，其他语句中又包含表达式等等，都是这样的嵌套模式，为了正确地弄清语言结构，人们必须递归地将
其映射到语言语法所允许的文本范围之内

如果要理解英语这样的一门自然语言，那么关于语法规则如何在人类大脑中表示，以及这些规则是先天具备的还是后天形成的这类问题，
就会引起激烈争辩。

如果只考虑形式语言，就能准确地知道如何将其语法结构形式化。我们通常使用一组称为**上下文无关语法**的规则来描述编程语言。
为了做到这一点，首先必须将程序的文本转换成一系列字元

## 词法分析

程序最简单的语法形式就是存储在文本文件中的一些列字符，对程序进行语法分析的第一步，是将字符分组成字元，忽略空格和注释。
这一步通常称为词法分析、扫描或字元化。

一旦程序被分组成字元，字元(不是字符)被看作程序的基本原子，字元集合就成为编译器的输入

字元包括不同的种类，比如`while`是**关键字**，`count`是**标识符**，`<=`是**操作符**等等。编程语言通常都指定其所允许
的字元类型，以及用于将字元组合成正确程序结构的准确语法规则

> 比如，一些语法规定`++`为合法的操作符字元，而其他语言可能不这样规定，有的编译器会认为两个连续`+`字符组成的标记
> 是不合法的

C 代码

```c
while (count <= 100) {
  count++;
}
```

字元化

```
while
(
count
<=
100
)
{
count
++
;
}

```

## 语法

一旦对程序进行语法分析，形成一系列字元，就面临更具挑战的任务，即将字元进行分许，理解成对应的规范结构。换句话说，
必须想办法考虑如何将这些字元组成变量声明、语句、表达式等语言结构

通过将字元集合按照预定义的规则集，即**语法**进行组合匹配，就可以实现分组和分类任务

几乎所有的编程语言，以及大多数用于描述复杂文件类型语法的其他形式语言，都可以使用上下文无关语法来描述。
上下文无关是一组规则，用来指定语言中的语法元素如何由更简单的元素组成。比如，Java 语法允许确定文本`count <= 100`
是正确的 Java 表达式。

事实上，每种语法都可以从两个方面来考察
从声明的观点来看，语法规定了可行的方案，来将字元(也称终结符)组合成更高级的语法元素(也称非终结符)

从分析的观点来看，语法是用于执行反向任务的规则，将给定的输入，即通过字元化阶段得到的字元集合，解析成非终结符、较低级的
非终结符，以及最后不能继续分解的终结符

因为语法规则是分层的，所以语法分析器生成的输出可以用称为`语法分析树`或`导出树`的树状数据结构来描述。
而其他一些编译器则隐式地表示程序结构，即时地进行代码生成和错误报告，这样的编译器不需要在内存中保存整个程序结构，
仅仅保存与当前被分析的元素相关的子树

## 递归下降分析

有很多算法可用来构建语法分析树，自顶向下的方法，也称为递归下降分析，是应用由语法规则描述的嵌套结构来尝试递归地
分析字元集合形成的输入流

现在来考虑如何编写实现该功能的语法分析器程序

对于语法中每个描述非终结字符的规则，可以为语法分析器程序配备递归子程序，该子程序用来递归分析非终结符。如果非终结符仅由
终结符原子构成，该程序就很容易处理它们。否则，对于规则右边的每个非终结符构建块，程序可以递归地调用`分析该非终结符`的程序。
整个处理过程递归进行，直到所有终结符原子元素全部被处理完毕

显然同样的逻辑，可以用来检查源程序中的语法错误，编译器越好，错误诊断的能力越强

每当一个非终结符有多种选择的导出规则时，其第一字元足以确定该非终结符所属的表达式类型，而不会出现不确定的情况，具有
这种属性的语法称为`LL(0)`。递归下降算法可以简洁明了地处理这类语法

## Jack 语言语法分析器

语法分析器的主要目的是读取 Jack 程序，根据 Jack 语法理解其语法结构，理解的意思是语法分析器在处理过程
中的每一步都必须确定当前读取的程序要素是`expression`, `statement`, `variable name`等等

语法分析器必须以完全递归的形式来保存语法结构的信息，没有此信息，就不可能进入下一步的代码生成阶段

## 语法分析器输入

每个`xxx.jack`文件都是字符流，根据 Jack 语言的语义元素所指定的规则，该字符流应该被字元化，形成字元流(即一系列的字元)
