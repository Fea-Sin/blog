# 面向对象 II

## 对象的存储空间

很多 C++书籍都介绍过一个对象需要占用多大的内存空间，最权威的结论是，非静态成员变量总和
加上编译器为了 CPU 计算做出的数据对齐和支持虚函数所产生的负担的总和

数据成员、成员函数、构造函数、析构函数和虚函数的空间占用

每个对象所占用的存储空间只是该对象的非静态数据成员的总和，其他都不占用存储空间，包括
成员函数和静态数据成员

函数代码是存储在对象空间之外的，而且函数代码段是公用的

## this 指针

在每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为`this`指针，它是
指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址

例如，当调用成员函数`a.volume`时，编译系统就把对象 a 的起始地址赋给`this`指针

`this`指针是隐式使用的，它是作为参数被传递给成员函数

代码定义

```c++
int Box::volume() {
  return (height*width*length);
}
```

C++把它处理为

```c++
int Box::volume(Box *this) {
  return (this->height * this->width * this->length)
}
```

可以用`*this`表示被调用的成员函数所在的对象，`*this`就是 this 所指向的对象，即当前
的对象

**this 指针有以下特定**

- 只能在成员函数中使用，在全局函数、静态成员函数中都不能使用 this

- this 指针是在成员函数的开始前构造，并在成员函数的结束后清除

- this 指针会因编译器不同而有不同的存储位置，可能是栈、寄存器或全局变量

- this 是类的指针

- this 指针只有在成员函数中才有定义

- 普通的类函数（非静态成员函数、静态成员函数）都不会创建一个函数表来保存函数指针，只有虚函数才会
  被放到函数表中

## 析构函数和构造函数的执行顺序

- 在全局范围中定义的对象，它的构造函数在文件中的所有函数(包括 main 函数)执行之前调用。但如果一个
  程序中有多个文件，而不同的文件中定义了全局对象，则这些对象的构造函数的执行顺序是不确定的，当 main
  函数或调用 exit 函数时，调用析构函数

- 如果定义的是局部自动对象(如在函数中定义对象)，则在建立对象时调用其构造函数。如果函数被多次调用，
  则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数

- 如果在函数中定义静态(static)局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，
  在调用结束时对象并不释放，因此也不调用析构函数，只在 main 函数结束或调用 exit 函数结束程序时，
  才调用析构函数

## 继承与派生

声明派生类的一般形式

```
class 派生类名: [继承方法] 基类名 {
  派生类新增加的成员
}
```

其中的继承方式包括 public, private, protected，此项是可选的，如果不写此项，则默认为 private

- 公有继承(public inheritance) 基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为为基类私有

- 私有继承(private inheritance) 基类的公有成员和保护成员在派生类中成了私有成员，其私有成员仍为基类私有

- 受保护的继承(protected inheritance) 基类的公有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有

保护成员的意思是，不能被外界引用，但可以被派生类的成员引用

在多级派生的情况下，各成员的访问属性仍按以上原则确定

无论哪一种继承方式，在派生类中是不能访问基类的私有成员的，私有成员只能被本类的成员函数所访问，毕竟
派生类与基类不是同一个类

## 派生类的构造函数与析构函数

派生类的数据成员由所有基类的数据成员与派生类新增的数据成员共同组成

**派生类的构造函数与析构函数的调用顺序**

前面已经提到，构造函数和析构函数的调用顺序是先构造的后析构，后构造的先析构。那么基类和派生类中
的构造函数和析构函数的调用的调用顺序，规则如下

- 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在派生表中的出现的顺序，而不是他们在成员初始化
  表中的顺序

- 成员类对象构造函数。如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们
  出现在成员初始化表中的顺序

- 派生类构造函数
  而析构函数的调用顺序与构造函数的调用顺序正好相反，将上面 3 点内容中顺序反过来用就可以了，即：首先调用
  派生类的析构汗水，其次再调用成员类对象的析构函数，最后调用基类的析构函数

**析构函数在下面 3 种情况时被调用**

- 对象生命周期结束被销毁时

- delete 指向对象的指针时，或 delete 指向对象的基类类型指针，而其基类虚构函数是虚函数时

- 对象 i 是对象 o 的成员，o 的析构函数被调用时，对象 i 的析构函数也被调用
