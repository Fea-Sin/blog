# 编译

```bash
g++ helloworld.cpp
```

上述命令，执行了 4 个步骤，预处理、编译、汇编和链接

## 预处理

预处理过程主要处理那些源代码文件只能够的以`#`开始的与编译指令

- 将所有的`#define`删除并且展开所有的宏定义

```c++
#define a b
```

对于这种伪指令，预编译所要做的是将程序中的所有 a 用 b 替换，但作为字符串常量的 a 则不被替换
还有`#undef`则将取消对某个宏的定义，使以后该串出现不再被替换

- 处理所有条件预编译指令，比如`#if`, `#ifdef`, `#elif`, `#else`, `#endif`

这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对那些代码进行处理。
预编译程序将根据有关的文件，将那些比必要的代码过滤掉

- 处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是
  递归进行的，也就是说被包含的文件可能还包含其他文件
  采用头文件的目的主要是为了使某些定义可以供多个不同的 cpp 源程序使用
  预编译将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。
  包含到 cpp 源程序中的头文件可以是系统提供的，这些头文件一般被放在`/usr/include`目录下
  在程序中`#include`它们时要使用尖括号`<>`
  另外开发人员也可以定义自己的头文件，这些文件一般与 c 源程序放在同一目录下，此时在`#include`中要
  用双引号`""`

- 过滤所有的注释`//`, `/**/`中的内容

- 添加行号和文件标识，以便于编译时编译器产生调试用的行号信息以用于编译时产生编译错误或
  警告时能够显示行号

- 保留所有的`#pragma`编译器指令，因为编译器需要使用它们

经过预编译后的`.i`文件不包含任何宏定义，因为所有的宏定义已经被展开，并且包含的文件也已经
被插入到`.i`文件中。
当无法判断宏定义是否正确或头文件包含是否正确时，可以查看预处理后的文件来确定问题

```
g++ -E helloworld.cpp -o helloworld.i
```

## 编译

编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析以及优化后产生相应
的汇编代码文件，这个过程往往是整个程序构建的核心部分，也是最复杂的部分之一

编译器究竟做了什么

从最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具，比如可以用
C/C++语言写一个程序可以使用编译器将其翻译成机器可以执行的指令及数据

编译的过程一般分为 6 步，扫描(词法分析)，语法分析，语义分析，源代码优化，代码生成和目标代码优化

源代码 -词法分析-> 产生一堆单词(token) -语法分析-> 语法树 -语义分析-> 带变量的语法树 -源代码优化->
中间语言 -代码优化-> 目标代码 -目标代码优化-> 最终目标代码

**编译命令**

```
g++ -S helloworld.i -o helloworld.s
```

### 词法分析

词法分析，运用一种类似有限状态机的算法可以很轻松地将源代码的字符序列分割成一系列的记号

词法分析产生的记号一般可分分为如下几类，关键字、标识符、字面量(包含数字、字符串等)和
特殊记号(如加号、等号)在识别记号的同时，扫描器也完成了其他工作。比如，讲标识符存放到
符号表中，将数字、字符串常量存放到文字表等，以备后面的步骤使用

有一个叫`lex`的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串
分割成一个个记号

> 预编译是交给一个独立预处理器

### 语法分析

语法分析器对由扫描器产生的记号进行语法分析，从而产生语法树。

语法分析器分析过程采用了上下文无关文法的分析手段，语法分析器生成的语法树就是以表达式为
节点的树

在语法分析的同时，很多运算的优先级和含义也被确定下来，比如乘法表达式的优先级比加法高，
而圆括号表达式的优先级比乘法高等等
如果出现了表达式不合法，比如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析
阶段的相关错误

### 语义分析

语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句真正含义。编译器所能
分析的语义是静态语义，所谓静态语义是指在编译期间可以确定的语义。
与之对应的动态语义就是只有在运行期间才能确定的语义

静态语义通常包括声明和类型的匹配以及类型的转换等。比如当一个浮点型的表达式赋值给一个整型的表达式时，
其中隐含了一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，编译器将会报错

动态语义一般指在运行期间出现的语义相关的问题，比如将 0 作为除数是一个运行期语义错误

经过语义分析阶段后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转化，语义分析程序会在
语法树中插入相应的转换节点

现代编译器有着很多层次的优化，往往在源代码级别会有一个优化过程，源代码级优化器在不同编译器中可能会有
不同的定义和一些其他差别。
源代码优化器会在源代码级别进行优化，例如`2+7`这个表达式可以被优化掉，因为它的值在编译期间就可以确定

源代码优化器往往将整个语法树转换成中间代码，它是语法树的顺序表示，其实它已经非常接近目标代码了。但中间
代码一般根目标机器和运行环境是无关的，比如不包含数据的尺寸、变量的地址和寄存器的名字
中间代码使得编译器可以被分成前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端则负责将中间
代码转换成目标机器代码
这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同的机器平台的数个后端

编译器后端主要包括代码生成器和目标代码优化器，代码生成器将中间代码转换成目标机器代码，这个代码十分依赖于
目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等

```c++
array[index] = (index+5)*(2+7)
```

```
movl  index, %ecx        ; value of index
addl  $5, %ecx           ; ecx=ecx+5
mull  $9, %ecx           ; ecx=ecx*9
movl  index, %eax        ; value of index to eax
movl  %ecx, array(,eax,5); array[index]=ecx
```

最后目标代码优化器对上面目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法等

经过了词法分析、语法分析、语义分析、源代码优化、目标代码生成和目标代码优化，编译器将源代码
终于编译成了目标代码。
但是这个目标代码中有一个问题，`index`和`array`的地址还没确定

如果`index`和`array`定义在跟上面的源代码同一个编译单元里面，那么编译器可以为`index`和`array`分配空间，
确定它们的地址，但如果是定义在其他的程序模块中呢

定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才确定，所以现代的编译器可以
将一个源代码文件编译成一个未链接的目标文件，然后由连接器最终将这些目标文件链接起来形成可执行文件

## 链接

把每个源代码模块独立地编译，然后将它们组装起来，这个组装模块的过程就是链接。链接
的主要内容就是把各个模块之前相互引用的部分都处理好，使得各个模块之间能够正确的衔接

链接从原理上讲，无非就是把一些指令对其他符号地址的引用加以修正，链接过程主要包括地址和
空间的分配、符号决议和重定位等这些操作

### 静态链接

链接分为静态链接和动态链接。对函数库的链接是放在编译时期完成的是静态链接，所有相关的目标
文件与牵涉到的函数库被链接合成一个可执行文件。
程序运行时，与函数库再无瓜葛，因为所有需要的函数已复制到相关位置，这些函数库被称为静态库

### 动态链接

除了静态链接，也可以把对一些库函数的链接载入推迟到程序运行时期(runtime)，这就是动态链接库
(dynamic link library)技术。动态库文件命名规范和静态库文件命名规范类似，也是在动态库名
增加前缀`lib`，但其文件扩展名为`.so`

动态载入时是通过代码复制的方式来满足不同进程的需要，而不能达到真正代码段共享的目的

### 动态库的搜索路径搜索的先后顺序

1. 编译目标代码时指定的动态库搜索路径
2. 环境变量`LD_LIBRARY_PATH`指定的动态库搜索路径
3. 配置文件`/etc/ld.so.conf`中指定的动态库搜索路径，可以在该文件中追加路径
4. 默认的动态库搜索路径`/lib`
5. 默认的动态库搜索路径`/usr/lib`

修改环境变量的具体命令

```
export LD_LIBRARY_PATH=/usr/lib:$LD_LIBRARY_PATH

sudo ldconfig
```

### 静态链接库和动态链接库的各自特点

- 动态链接库有利于进程间资源共享

- 将一些程序升级变得简单。用静态库，如果库发生变化，使用库的程序要重新编译，使用动态库，
  只要动态库提供给该程序的接口没变，只要重新用新生成的动态库替换原来就可以了

- 由于静态库在编译的时候，就将库函数装载到程序中去了，而动态库函数必须在运行时才被装载，
  所以程序在执行的时候，用静态库速度更快一些

## g++ 与 gcc 的区别

- 后缀为`.c`的文件 gcc 把它当作是 C 程序，而 g++当作是 C++程序，后缀为`.cpp`的文件，
  两者都会认为是 C++程序。C++是 C 的超集，但两者对语法的要求是有区别的
