# TCP 协议

网络通信是通过网络将各个孤立的设备进行连接，通过信息交换实现人与人、人与计算机、计算机与计算机
之间的通信。网络通信中最重要的就是网络通信协议，而网络通信协议中最重要的就是 TCP/IP 协议

国际标准化组织 ISO 于 1981 年正式推荐了一个网络系统结构-七层参考模型，也叫做开放系统互联模型。

- 7，应用层，提供应用程序间通信，计算机应用程序如 FTP、SMTP、HTTP 等，程序级数据

- 6，表示层，处理数据格式、数据加密等，计算机编码方式如图像编解码、URL 字段传输编码等，程序级数据

- 5，会话层，建立、维护和管理会话，计算机建立会话如 session 认证、断点续传，程序级数据

- 4，传输层，建立主机端到端连接，计算架进程和端口，数据段

- 3，网络层，寻址和路由选择，网络路由器、防火墙、多层交换机，数据包

- 2，数据链路层，提供介质访问、链路管理等，网络网卡、网桥、交换机，帧

- 1，物理层，比特流传输，网络中继器、集线器、网线，比特(bit)

当一台主机需要传送用户的数据时，数据首先通过应用层的接口进入应用层。在应用层，用户的数据被加上
应用层的报头，形成应用层协议数据单元。然后被递交给表示层，表示层并不关心上层应用层的数据格式而是
把整个应用层递交的数据看成是一个整体进行封装，加上表示层的报头。然后递交给到会话层，同样会话层、传输层、
网络层(假设用 TCP 传输 + IP 包头)、数据链路层(把上层的 TCP 数据+IP 包头统一称为帧数据)，数据链路层还要
给网络层递交的数据加上数据链路层报尾形成最终的一帧数据

当一帧数据通过物理层传输到目标主机的物理层时，该主机的物理层把它提交到上层数据链路层，数据链路层负责去掉数据帧
的帧头部和尾部同时进行数据校验，如果没有出错则递交给上层网络层，一层一层，最终原始数据被递交目标主机
的具体应用程序中

## 四层网络模型

七层模型是学术上的概念，使用并不广泛，还有一个四层模型，使用最为广泛-TCP/IP 分层模型

TCP/IP 协议被组织成 4 个概念层，TCP/IP 协议族并不包含学术上的物理层和数据链路层

**4 层 TCP/IP 协议**

- 网络接口层

网络接口层包括用于协作 IP 数据在已有的网络介质上传输的协议，实际上 TCP/IP 标准并不定义 ISO 数据链路层和
物理层相应的功能，网络接口层提供了 TCP/IP 协议的数据结构和实际物理硬件之间的接口

- 网间层

网间层对应 OSI 七层参考模型的网络层，负责数据的包装、寻址和路由，还包括 ICMP 网间控制报文协议用来提供网络
诊断信息

- 传输层

传输层对应 OSI 七层参考模型的传输层，它提供两种端到端的通信服务。TCP 可靠的数据流运输服务，UDP
不可靠的用户数据服务

- 应用层

应用层对应于 OSI 七层参考模型的应用层和表示层。因特网的应用层协议包括 Finger、Whois、FTP、
Gopher、HTTP、Telent、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP(网络新闻传输协议)等

7 层模型中，第二层数据链路层上的数据叫`Frame`，第三层网络层的数据叫`Packet`，第四层传输层的数据叫`Segment`

应用程序的数据首先会打包到`TCP`的`Segment`，然后打包到 IP 的`Package`，然后再打包到以太网的`Frame`中

## TCP 头部

- TCP 的包是没有 IP 地址的，那是 IP 层的事，但是有源端口和目的端口

- 一个 TCP 连接需要 4 个元组(src_ip、src_port、dist_ip、dist_port)

- Sequence Number 是包的序号，用来解决网络包乱序问题

- Acknowledgement Number 就是 ACK，用于确认收到，用来解决不丢包的问题

- Advertised-Window 也就是著名的滑动窗口，用于解决流控制问题

- TCP Flag 也就是包的类型，主要是用于操控 TCP 的状态机的

## TCP 状态流转

其实，网络上的传输是没有连接的，TCP 也是一样的。而 TCP 所谓的连接，其实只不过是通信的
双方维护一个连接状态，让它看上去好像有连接一样。所以 TCP 的状态变换是非常重要的。看一下
著名的 3 次握手与 4 次挥手

TCP 连接的建立可以简单等称为 3 次握手

- 第一次握手，建立连接时，客户端发送 SYN 包(SYN=J)到服务器，并进入 SYN_SEND 状态，等待
  服务器确认

- 第二次握手，服务器端收到 SYN 包，必须确认客户的 SYN（ACK=J+1），同时自己也发送一个 SYN 包(SYN=K)，
  即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态

- 第三次握手，客户端收到 SYN+ACK 包，向服务器发送确认包 ACK(ACK=K+1)，此包发送完毕，客户端和服务端进入
  ESTABLISHED 状态，完成 3 次握手

完成三次握手，客户端和服务器开始传送数据，也就是 ESTABLISHED 状态

结束连接，需要 4 次握手

TCP 有一个特别的概念叫半关闭，这个概念是说，TCP 的连接是全双工(可以同时发送和接收)连接，因此在关闭
连接的时候，必须关闭传和送两个方向上的连接

客户机给服务器一个 FIN 的 TCP 报文，然后服务器返回一个确认 ACK 包文，并且发送一个 FIN 报文，
当客户机回复 ACK 报文后，4 次握手，连接就结束了

对于建连接的 3 次握手，主要是要初始化 Sequence Number 的初始值，通信的双方要互相通知对方自己的
的初始化 Sequence Number(SYN)，这个号要作为以后的数据通信的序号，以保证应用层接收的数据不会因为
网路上的传输问题而乱序

对于 4 次挥手，发送方和接收方都要 FIN 和 ACK，只不过有一方是被动的，所以看上去就成了所谓的 4 次挥手。
如果两边同时断开连接，那就会进入到 CLOSING 状态，然后到达 TIME_WAIT 状态

## TCP 状态流转图

1. CLOSED 表示初始状态

2. LISTEN 表示服务器端的某个 socket 处于监听状态，可以接受连接

3. SYN_SENT 在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此时客户端
   就进入 SYN_SENT 状态，等待服务端的确认

4. SYN_RCVD 表示服务端收到 SYN 报文，在正常情况下，这个状态是服务器端的 socket 在建立 TCP 连接时的 3 次
   握手会话过程中的一个中间状态，很短暂基本上用网络查询工具 netstat 是很难看到这种状态的，除非特意写一个客户端
   测试程序，故意将 3 次 TCP 握手过程中最后一个 ACK 报文不予发送。因此这种状态时，当收到客户端的 ACK 报文
   后，它会进入到 ESTABLISHED 状态

5. ESTABLISHED 表示连接已经建立了

6. FIN_WAIT_1 这个是已经建立连接之后，其中一方请求终止连接，等待对方的 FIN 报文。FIN_WAIT_1 状态是当 socket
   在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时 socket 即将进入到 FIN_WAIT_1 状态。
   而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态

7. FIN_WAIT_2，实际上 FIN_WAIT_2 状态下的 socket 表示半连接，即有一方要求关闭连接，但是对方还有数据发送，稍后
   再关闭连接

8. TIME_WAIT 表示收到了对方的 FIN 包文，并发送了 ACK 包文，就进入了 TIME_WAIT 状态

9. CLOSING 状态，这种状态比较特殊，实际情况中应该很少见，属于比较罕见的例外状态。正常情况下，
   当发送 FIN 报文后，按理应该先收到(或同时收到)对方的 ACK 报文，再收到对方的 FIN 报文。但是 CLOSING
   状态表示你发送 FIN 报文后，并没有收到对方的 ACK 报文，反而收到了对方的 FIN 包文。为什么会出现这种
   情况，那就是双发几乎同时关闭了一个 socket 的话，那么就出现了双方同时发送 FIN 报文的情况，这会出现 CLOSING 状态

10. CLOSE_WAIT 这种状态的含义其实是表示在等待关闭，怎么理解？当对方关闭一个 socket 后发送 FIN 报文给自己时，系统将毫无
    疑问地回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来，实际上你真正需要考虑的事情是查看你是否还有
    数据发送给对方，如果没有，那就可以关闭这个 socket 了，发送 FIN 报文给对方，即关闭连接

11. LAST_ACK 这个状态比较好理解，它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文

12. CLOSED 当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了

FIM_WAIT_2 状态，这就是著名的半关闭状态了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这种状态下，
应用程序还有接收数据的能力，但是已经无法发送数据

## TCP 超时重传

TCP 每发送一个报文段，就对这个报文段设置一次计时器，只要计时器设置的重传时间到了，但没有
收到确认，就要重传这一报文段，这个就叫作超时重传

`telnet ip port` 可以查看一个机器上的某一个端口是否可以访问

## 滑动窗口

TCP 是双工的协议，会话的双方都可以同时接收、发送数据。TCP 会话的双方都各自维护一个发送窗口和一个接收窗口。
其中各自的接收窗口取决于应用、系统、硬件的限制，各自的发送窗口则要求取决于通告的接收窗口

TCP 的滑动窗口的可靠性也是建立在确认重传的基础上的。发送窗口只有收到对端对于本段发送窗口内字节的 ACK 确认，才会移动
发送窗口的左边界。接收窗口只有在前面所有的段都确认的情况下才会移动左边界。在前面还有字节未接受但收到后面的字节
的情况下，窗口不会移动，并不对后续字节确认，以此确保对这些数据重传

## TCP 拥塞控制

计算机网络中的带宽、交换节点中的缓存和处理机等，都是网络的资源。在某段时间内，若对网络中某一资源的需求超过了该资源
所能提供的可用部分，网络的性能就会变坏

拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不至过载。拥塞控制是一个全局的过程，和流量控制不同，
流量控制指点对点通信量的控制

- 慢开始，拥塞避免

- 快重传，快恢复

从整体上来讲，TCP 拥塞控制窗口变化的原则是加法增大、乘法减小。可以看出 TCP 的该原则可以
较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的
空间，从而保证整个的公平性

## TCP 网路编程

网络中进程之间如何通信，首先解决的问题是如何唯一标识一个进程，否则通信无从谈起。本地可以通过
PID 来唯一标识一个进程，网络是利用三元组(IP 地址、协议、端口)就可以唯一标识主机中的应用程序

网络中的进程是通过 socket 来通信那么什么是 socket，socket 起源于 UNIX，而 UNIX/Linux 基本
哲学之一就是`一切皆文件`，都可以用`open -> read/write -> close`模式操作，socket 即是一种
特殊的文件

就目前而言，几乎所有的应用程序都是采用 socket，而现在又是网络时代，网络中的进程通信无处不在

## TCP 协议通信的 socket

- 服务器

创建 socket -> 绑定 socket 和端口 -> 监听端口 -> 接收来自客户端的连接请求 ->
从 socket 中读取字符 -> 关闭 socket

- 客户端

创建 socket -> 连接指定的计算机的端口 -> 向 socket 中写入信息 -> 关闭 socket

多网卡机器，会有多个 IP 地址，例如你的机器有 3 个 IP: 192.168.1.1、202.202.202.202、61.1.2.3，
如果 socket 中传入`192.168.1.1`，然后监听 100 端口，这时其他机器只有连接`192.168.1.1:100`才能
成功

如果`0.0.0.0` 的地址，表示不确定地址，或所有地址，此时无论连接哪个 IP 都能连上

## 网络字节序与主机序

不同的 CPU 有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，称为主机序。常见的
有两种

- Little Endian 将低序字节存储起始地址

- Big Endian 将高序字节存储在起始地址

为什么要注意字节序的问题呢，如果程序只在单机环境下运行，并且不和其他程序打交道，那么完全可以忽略字节
序的存在

C/C++ 语言编写的程序里数据存储顺序是跟编译平台所在的 CPU 相关的，而 Java 编写的程序则唯一采用 Big Endian
方式来存储数据。因此你的 C 程序传给 Java 程序之前有必要进行字节序的转换工作

所有的网络协议也都是采用 Big Endian 的方式来传输数据的。所以有时也会把 Big Endian 方式称之为网络字节序。当两台
采用不同字节序的主机通信时，在发送数据之前都必须经过字节序转换成网络字节序再进行传输

## 封包和解包

对于 UDP 来说就不存在拆包的问题，UDP 是一个数据包协议，也就是两段数据时有界限的，在接受
端要么接收不到数据要么就是接收一段完整的数据

TCP 是个流协议，所谓流，就是没有界限的一串数据，大家可以想象河里的流水，是连成一片的，其间是
没有分界线的

由 Nagle 算法造成的发送段的粘包。Nagle 算法是一种改善网络传输效率的算法，当要提交一段数据为 TCP
发送时，TCP 并不立刻发送此段数据，而是等待一小段时间，看看在等待期间是否还有要发送的数据，若有则会
一次把多段数据发送出去

接收端接收不及时造成接收端粘包

封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了。根据固定的包头长度以及包头
中含有的包体长度的变量值就能正确的拆分出一个完整的数据包

利用底层的缓冲区来进行拆包时，TCP 也维护了一个缓冲区，这样一来就不需要为每一个连接分配一个缓冲区了，可以
按照包头的数据，区分一个完整的 TCP 包
