# Linux 程序内存空间布局

一个典型的 Linux 下的 C 程序内存空间有如下几个部分组成

- 代码段(.text segment): 代码段通常是指用来存放程序执行代码的一块内存区域，这部分区域的大小在程序
  运行前就已经确定，并且内存区域通常属于只读。在代码段中，也有可能包含一些只读的常数变量。程序段是程序代码
  在内存中的映射，一个程序可以在内存中有多个副本

- 初始化数据段(.data segment): 通常是指用来存放程序中已初始化的全局变量的一块内存区域，例如，位于所有函数
  之外的全局变量`int val = 10`。需要强调的是，以上内容都是位于程序的可执行文件中，内核在调用`exec`函数启动
  该程序时从源文件中读入，数据段属于静态内存分配

- 未初始化数据段(.bss segment): 通常是指用来存放程序中未初始化的全局变量的一块内存区域

- 堆(heap): 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态地扩张或缩减。当
  进程调用`malloc/free`等函数分配内存时，新分配的内存就被动态添加到堆上或释放的内存从堆中被剔除

- 栈(stack): 栈又被称堆栈，存放程序的局部变量(但不包括 static 声明的变量，static 意味着在数据段中
  存放变量)，除此以外，在函数被调用时，栈用来传递参数和返回值。由于栈的先进后出特点，所以栈特别方便用来
  保存/恢复调用现场。而动态内存分配，需要程序员手工分配、手工释放

## 堆栈的区别

**申请方式不同**

栈: 由系统自动分配。例如，声明在函数中一个局部变量`int b`，系统自动在栈中为 b 开辟空间

堆: 需要程序员自己申请，并指明大小，在 c 中用`malloc`函数，如`p1 = (char*)malloc(10)`，
在 C++中用`new`运算符

**申请后系统的响应不同**

栈: 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常，提示栈溢出

堆: 首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历链表
寻找第一个空间中大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间
分配给程序。其次，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中
delete 语句才能正确的释放本内存空间，最后，由于找到的堆节点的大小不一定正好等于申请的大小，系统
会自动地将多余的那部分重新放入空闲链表中

**申请大小的限制不同**

栈: 栈时向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先
规定好的。在 Linux 下，栈的大小是一个常数，如果申请的空间超过栈的剩余空间时，将提示`overflow`，因此，
能从栈获得的空间较小

用`ulimit -a` 命令可以看到栈的大小

堆: 堆是向高地址扩展的数据结构，不是连续的内存区域，这是由于系统是用链表来存储的空闲内存地址的，
自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。
由此可见，堆获得的空间比较灵活，也比较大

**申请效率不同**

栈由系统自动分配，速度快，但程序员是无法控制的

堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便

**堆和栈中的存储内容不同**

栈: 在函数调用时，第一个进栈的是主函数中后的下一条指令的地址，然后是函数的各个参数，
在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量，注意静态变量
是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，
也就是主函数中的下一条指令，程序由该点继续运行

堆: 一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排

### 程序在内存中的分配情况

传入的参数，局部变量，都是在栈顶分布，随着子函数的增多而向下增长

函数调用地址，全局变量，静态变量都是在分配内存的底部存在，而 malloc 分配的堆则存在于这些内存之上，并向上生长
