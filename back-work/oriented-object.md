# 面向对象的 C++

面向对象编程的主要思想是把构成问题的各个事务分解成各个对象，建立对象的目的不是为了
完成一个步骤，而是为了描述一个事物在解决问题中经过的步骤和行为

对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。

类是创建对象的模版，一个类可以创建多个相同的对象。对象是类的实例，是按照类的规则创建的

对象的属性和方法统称为对象的成员，属性是一个变量，用来表示一个对象的特征。
方法是一个函数，用来表示对象的操作

正如结构体类型和结构体变量一样，需要先声明一个结构体类型，再用它去定义结构体变量。在 C++中
也是先声明一个类的类型，然后用它去定义若干个同类型的对象

类是抽象的，不占用存储空间；而对象是具体的，占用存储空间

**类类型的声明**

```c++
class 类名 {
  private:
    私有的数据和成员函数;
  public:
    共有的数据和成员函数;
}
```

`private`和`public`称为成员访问限定符

声明类的方法是由声明结构体类型的方法发展而来的。`struct`中的成员访问权限默认是`public`，而`class`中
默认是`private`

在 C 语言里，`struct`中不能定义成员函数，而在 C++中，增加了`class`类型后，扩展了`struct`的功能，`struct`
中也能定义成员函数了

**一个对象的声明方式有以下几种**

- class 类名 对象名

- 类名 对象名

## 成员函数

类的成员函数是函数的一种，与普通函数一样，具有返回值和函数类型。它与一般的函数的区别
在于，它是属于类的成员，出现在类体中。它可以被指定为`private`, `protected`, `public`

在使用成员函数时，要注意它的权限以及作用域。私有的成员函数只能被本类中其他成员函数使用，
而不能在类外被调用

成员函数中可以使用类中的任何成员，包括私有的和公用的

## 类的封装性

C++ 中通过类实现类封装性，把数据和这些数据有关的操作封装在一个类里。

人们在使用时，往往不关心类中的具体实现，而只需知道调用那个函数会得到什么结果，能实现
什么功能即可

为了实现类对象的封装性（数据隐藏和提供访问接口），类类型定义为类成员提供了私有、公有和受保护
的 3 种基本访问权限供用户选择

- 私有成员
  只限于类成员访问

- 公有成员
  允许类成员和类外的任何访问

- 受保护成员
  允许类成员和派生类成员访问，不运行类外的任何访问

除了限制访问权限，在写代码时经常要注意`将接口与实现分离`，这也是隐藏信息的一个重要手段

**接口与实现分离**，有以下两个好处

- 如果想修改或者扩充类的功能，只需要修改类中的实现，类外部分可以不用修改

- 如果发现类中的数据成员有错，则只需要在类内检查访问这些数据成员的成员函数

## 构造函数

数据成员是不能在类中初始化的，而构造函数，正是为此而生，主要用来处理数据成员的初始化。
它不需要用户调用，而是在建立对象时自动执行的。

构造函数的名字必须与类名相同，而不能由用户任意命名，以便编译系统能识别它并把它作为构造函数
处理。它是一个没有返回值的函数

如果用户自己没有定义构造函数，那么 C++系统就会自动为其生成一个构造函数，只是这个构造函数的函数体
是空的，什么也不做，当然也不进行初始化

构造函数分为不带参数的构造函数和带参数的构造函数，不带参数的构造函数使该类的每一个对象都得到相同的
初始值，带参数的构造函数则可以方便的实现对不同的对象进行不同的初始化

在 C++中，一个类可以同时定义多个构造函数，以提供不同的初始化方法。这些构造函数的参数个数不同或
参数的类型不同，这就是构造函数的重载

调用构造函数时不必给出实参的构造函数，称为默认构造函数，无参的构造函数属于默认构造函数。
一个类只能有一个默认构造函数，即使一个类中有多个构造函数，但建立对象时，都只执行其中一个构造函数

## 析构函数

析构函数的名字是类名的前面加一个`~`符号。在 C++中`~`符号是位取反运算符，析构函数的作用与构造函数
相反。它也不需要用户来调用，它是在对象声明周期结束时自动执行的

程序执行析构函数的 4 种时机

- 如果在函数中定义了一个对象，当这个函数调用结束时，对象会被释放，且在对象释放前会自动执行析构函数

- static 局部对象在函数调用结束时对象不释放，所以也不执行析构函数，只有在 main 函数结束或调用 exit 函数
  结束程序时，才调用 static 局部对象的析构函数

- 全局对象则是在程序流程离开其作用域时，才会执行该全局对象的析构函数

- 用 new 建立的对象，用 delete 释放该对象时，会调用该对象的析构函数

析构函数的作用不是删除对象，而是在撤销对象占用的内存前完成一些清理工作，使得这些内存可以供新对象使用。析构函数
的作用也不限于释放资源方面，它还可以被用来执行用户希望在最后一次使用对象之后所执行的任何操作

析构函数是对象释放内存前执行的，如果用回没有编写析构函数，编译系统会自动生成一个默认的析构函数，但不进行任何
操作

## 静态数据成员

有时需要为某个类的所有对象分配一个单一的存储空间。数据当成全局变量那样去存储，但又被隐藏在类的内部，而且清楚
地与这个类相联系。这个可以可以用类的静态数据成员来实现

类的静态成员拥有一块单独的存储区，而不管创建了多少个该类的对象，所有这些对象的静态数据成员都共享这一块静态
存储空间，这就为这些对象提供了一种互相通信的方法

静态数据成员是属于类的，它只在类的范围内有效，可以是`public`, `private`, `protected`的范围

如果一个静态数据成员被声明而没有被定义，连接器会报告一个错误。定义必须出现在类的外部而且只能定义一次

C++ 静态数据成员被类的所有对象共享，包括该类的派生类的对象。派生类对象与基类对象共享基类的静态数据成员。
静态的数据成员在内存中只占一份空间，提高效率。

如果在一个函数中定义了静态变量，在函数结束时该静态变量并不会被释放，仍然存在并保留其值。静态数据成员
也类似，它不随对象的建立而分配空间，也不随对象的撤销而释放。静态数据成员是程序在编译时被分配空间，
到程序结束时释放空间

静态数据成员可以通过对象名引用，也可以通过类名来引用

## 静态成员函数

与数据成员类似，成员函数也可以定义为静态的，在类中声明函数的前面加`static`关键字就成了静态成员函数

```c++
static int volume()
```

和静态数据成员一样，静态成员函数也是类的一部分，而不是对象的一部分。如果要在类外调用共用的静态成员函数，
要用类名和域运算符`::`

```c++
Box::volume();
```

实际上也允许通过对象名调用静态成员函数

```
a.volume()
```

但这并不意味着此函数时属于对象 a 的，而是用 a 的类型而已

与静态数据成员不同，静态成员函数的作用不是为了对象之间的沟通，而是为了能处理静态数据成员

静态成员函数与非静态成员函数的根本区别是，非静态成员函数有`this`指针，而静态成员函数没有
`this`指针。由此决定了静态成员函数不能访问本类中的非静态成员

并不是绝对不能引用本类中的非静态成员，只是不能进行默认访问，因为无法知道应该去找那个对象。如果
一定要引用本类的非静态成员，应该加对象名。如

```c++
cout<< a.width <<endl;
```

最好养成好的习惯，只用静态成员函数引用静态数据成员，而不引用非静态数据成员。这样思路更清晰、
逻辑更清楚，不易出错
