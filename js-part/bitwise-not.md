## Bitwise NOT (~)

将操作数的每个位按位 NOT 操作(~)，像其他的按位操作，它将操作数转化为 32-bit 有符号的整数

```js
const a = 5; // 00000000000000000000000000000101
const b = -3; // 11111111111111111111111111111101
```

`~a`: 1111 1010 -> -6;
负数的值需要转化为补码查看 反码: 00000101，加 1: 00000110 -> 6

`~b`: 0000 0010 -> 2

## 负数的二进制表示法

假设有一个 int 类型的数，值为 3，那么我们知道它在计算机中表为

```
0000 0011
```

**在计算机中，负数以其正值的补码形式表示**

### 什么是补码

要先从原码、反码说起

原码： 一个整数，按照绝对值大小转换成二进制数，称为原码
反码： 将二进制数按位取反，所得的二进制数称为原二进制数的反码
补码： 反码加 1 称为原二进制数的补码

所以`-3`在计算机中表示为: 1111 1101
原码：0000 0011
反码：1111 1100
补吗：1111 1101

## 计算机为什么用补码表示负数

如何来表示 -(-3)

1111 1101 取反: 0000 0010，加 1: 0000 0011

负数采用补码，加法和减法就可以用同一种电路完成

## 补码的本质及正确性

我们要先看一下模的概念

`模`是指一个计量系统的计数范围。如时钟、计算机也可以看成一个计量机器，它也有一个计量范围，即存在一个模

时钟的计量范围是`0~11`，`模=12`

n 位计算机范围是`0~2^n-1`，`模=2^n`

任何计量器，均可化减法为加法运算

假设当前时钟指向 10 点，而准确时间是 6 点，调整时间可以有以下两种方法

你可以往回拨 4 个小时
也可向前拨 8 小时(12+6-10)

在以 12 为模的系统中，加 8 和减 4 效果是一样的
实际上以 12 为模的系统中，11 和 1，10 和 2，9 和 3，7 和 5，6 和 6 都有这个特性，共同的特点是
两者相加等于模

**对于计算机，其概念和方法完全一样，在 8 位二进制系统中模为 2^8，在这样的系统中，减法问题可以化成加法问题**

而减法在数学上就是加对应数的负数，故负数可以用补码表示

至此，减法与加法可以用统一的实现，**负数也就采用了补码表示**
